# Rust操作系统异步函数跟踪方案（2025-05-04）

## 1. 概述

Rust 在不进行换栈等上下文切换的情况下实现了异步执行流。实现的方法是，在编译的过程中，在用户标注的帮助下，异步函数被切割成若干个同步函数。因此只要我们能跟踪这些同步函数，就可以还原出异步函数的执行情况。

## 2. 相关工作

### 2.1 Rust 语言的异步语法

在 Rust 语言中, 异步函数的编写和调用是分离的.

编写异步函数的方法是编写 Future 结构体, 将异步代码放在 Future 结构体内的 poll 函数中. 当然, 开发者也可以用`async fn`等语法糖让编译器代替他生成 Future 结构体.

调用异步函数的方法是 `await` 标签. 这个标签的意思是 "阻塞当前执行流, 当调用的异步代码完成执行后, 恢复执行流". 

调用了异步函数的函数也是异步函数. 最顶层（入度为0的）的异步函数是 task. 

### 2.2 Rust 编译器对异步函数的改造

异步函数内的执行流可以被阻塞和恢复, 而常规函数是做不到的. 

其他语言的解决方案是

- 用轮询代替执行流的阻塞/恢复. 缺点：低效.
- 支持常规函数内换栈. 缺点：每种 ISA 的换栈代码都不同，不跨平台.

Rust 编译器的解决方案是: 

- 将异步函数的机器代码以 **阻塞/恢复点** （即 `await` 标签） 为界限分割成若干个不含 执行流阻塞/恢复 的常规函数.
- 这些常规函数被注册到由用户提供的异步运行时中，由异步运行时主动进行调用.
- 这些常规函数的返回值有统一的标准，从而异步运行时能得知这个阻塞/恢复点是否通过（即`await`的异步代码是否完成）. 通过的话会提取出返回值里异步任务的返回值并传递给下一个常规函数, 不通过的话会稍后再次调用同一个常规函数.

### 2.3 论文的工作

在符号表里，有poll.
在dwarf里，每一个 future 对应一个结构体。这个结构体里有 __awaitee 参数，跟踪它即可获得 future 依赖树。
依赖树断开的地方是自己实现的 future。不过好在自己实现的 future 在符号表里有

之前的异步函数跟踪方案（链接：代码：）的思路是：将异步执行流涉及的函数（当时）将火焰图中涉及 Future 的部分分离了出来，但是没有对协程做出拆分（）





### 2.4 石尚峰学长的工作





### 3. 设计

__awaitee 依赖树。

依赖树断开的地方是自己实现的 future。这些自己实现的 future 在符号表里有，在这些函数上插桩。

#### 3.3 评价
这样的话，我们能跟踪 async fn + 自己 impl future 了。
这样做的优点是不需要宏。
在目前版本的方案下我们仍然不考虑inline的情况。
其他的情况先不管。

### 4. 实现

4.1 依赖树：查找dwarf即可。
4.2 poll:
4.2.1 关键词过滤
考虑到五种 async 函数都带 poll 字眼， 过滤 poll.
4.2.2 设断点
函数开头的让gdb在debugee运行前设。
函数末尾的让gdb在函数头断点触发之后运行 finish 命令。（finish 命令的原理和栈帧有关，暂时没弄清）
4.2.3 设断点时收集数据
future定位：依靠 self 指针
时间：GDB支持
pid tid 有两种方案：
- 依靠异步运行时的“钩子断点”支持
- 直接抓取内存地址
poll结果：依靠收集返回值进行判断（gdb支持这个功能，原理暂时没弄清）
4.2.4 过滤
根据论文中的算法

### 4. 例子
见仓库 `example` 文件夹