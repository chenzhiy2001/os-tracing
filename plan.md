**Rust异步函数跟踪与操作系统调试 - 详细工作计划**&#x20;

### 1. 引言

本计划旨在实现对Rust异步函数和 Linux 操作系统的调试跟踪。最终愿景是用户可以在`code-debug` 操作系统调试工具中利用 GDB 跟踪 Linux，利用 eBPF 跟踪Rust 异步函数（这个异步函数可能运行于内核态，也可能运行于用户态）。

### 2. 研究背景与目标

- **总体目标**

  - 跨多个特权级：应用、内核和 **hypervisor**
  - 支持多种高级语言：Rust、C语言（xv6）
  - **支持 Rust 异步跟踪（编译选项，宏，甚至release，其他运行时）**
  - 支持多种操作系统：ArceOS unikernel、**ArceOS宏内核（starry）、Linux**
  - **rust eBPF in Linux => tracing rust program with async**
  - **jtag in openSBI (coprocessor)**
  - 支持多种CPU平台：RISC-V、x86-64
  - 支持多种开发板：QEMU、**x86 物理机（乾云工控机）**、星光2

我把任务分为三组：

  1) SBI跟踪。
    - 虚拟机上的SBI跟踪
      1. 扩展 GDB，支持文本终端 GDB 上跟踪 SBI 源代码 （1周）
        主要工作：建立机器态内存地址和SBI符号表文件的映射关系。
      2. 扩展 `code-debug` 插件的状态机，从而支持 M 态到 S 态的断点组切换（1周）
    - 实际硬件上的SBI跟踪：
      1. 支持有jtag的硬件（1周）
        主要工作：思路和虚拟机相同，工作量主要集中在调整编译参数上
      - 支持没有jtag的硬件（11月不安排，任务2）
        主要工作：在协处理器上跑 修改版 OpenSBI，该修改版 OpenSBI 能够处理jtag调试命令，并调试运行于主处理器上的OS

  2) 基于协处理器的、真实 x86 硬件上的 OS 调试
    - 在协处理器上跑 OpenSBI
    - 找到修改 OpenSBI，使其支持对 S 态内核进行调试的办法
    - 修改 OpenSBI，让它支持 JTAG 协议

  3) 跟踪 Rust 语言的异步函数
    - 使用他人论文的思路，支持其他 runtime 的跟踪调试
    - 利用这个思路，写一个支持调试 rust 异步函数的 eBPF，代替 Linux 原有的 eBPF

  4) hypervisor跟踪（不知道咋弄）

  5) Linux 跟踪，Starry跟踪
    - 调试工具原则上已经可以调试这两个 OS，因此大部分的工作是改调试器本身的配置文件
    - 添加工作2和工作3的人机交互界面

- **目标（2025年8月）**：

  - 扩展现有的`code-debug`工具，使其具备追踪Rust异步函数和Linux的能力；
  - 撰写并发表一篇关于本项目的学术论文。

### 3. 工作计划（边设计边施工）

#### 近一个月的计划

- **第1-2周**：确定追踪什么信息（函数调用时间点，异步函数调用关系，内存/io等）真实开发的时候调试异步函数的需求，新/老方法处理新/老问题

  - 了解 Rust 异步函数的生成方式，特别是 Release 编译模式下的
    - 参考：<https://www.eventhelix.com/rust/rust-to-assembly-async-await/>
  - 参考相关论文，如“Automatic Tracing in Task-Based Runtime Systems”和“CAT: Context Aware Tracing for Rust Asynchronous Programs”，学习现有的异步函数跟踪方法
  - 确定要处理的**问题**：参考相关论文/博客/直接问人，确定现有跟踪工具的缺陷/不方便的地方，进而确定本工具需要实现的功能
  - 确定实现这些功能的**方法**（eBPF还是uftrace还是GDB等）

- **第3-4周**：搭建基础设施

  - 为异步函数跟踪部分搭建基础设施（比如基于eBPF或uftrace），跟踪主函数中的异步函数的调用（能够跟踪到异步函数被调用即可）。

- **第5-6周**：实现异步函数的调用栈跟踪

  - 完善基础设施，添加对异步函数调用栈的捕获和记录功能。

- **第7-8周**：实现异步函数的状态机跟踪

  - 深入实现状态机跟踪功能，跟踪每个异步函数的状态转换（如`ready`和`pending`状态）。

#### **3.2 文档撰写与论文发表（1-2月）**

#### **3.3 阶段四：Linux调试跟踪（3-8月）**


- **第1-2周**：用 eBPF 调试 Linux 内的用户态 rust 代码（包含异步函数）
- **第3-5周**：尝试用 code-debug 调试工具调试 Linux，找到问题并修复
- **第6周**：添加用 eBPF 调试异步代码的用户界面

**总体计划概览**

**11月（详细计划）**
1. **支持 Rust 异步跟踪（编译选项、宏、release、其他运行时）**
   - **第一周**（11月1日 - 11月7日）
     - 学习和回顾 Rust 的异步编程和跟踪原理，尤其是编译器的相关选项和宏功能。
     - 研究现有的 Rust 异步跟踪工具和框架，例如 `tracing` crate，确定是否有现成的工具可以直接复用。
     - 熟悉如何使用编译器插入调试信息，了解如何在 `release` 模式中实现有效的异步跟踪。
   
   - **第二周**（11月8日 - 11月14日）
     - 实现一个简单的宏，用于追踪异步函数执行的开始和结束。
     - 为项目集成一个可配置的跟踪功能，初步实现编译选项的定制。
     - 使用 `cargo` 自定义配置文件创建调试与发布模式的配置，并进行初步测试。

   - **第三周**（11月15日 - 11月21日）
     - 优化异步跟踪逻辑，减少运行时开销，确保在 `release` 模式下的高效性。
     - 引入其他异步运行时（如 `tokio` 或 `async-std`），验证跟踪宏的兼容性。
     - 与团队讨论初步实现的设计，收集反馈，做出改进。

   - **第四周**（11月22日 - 11月30日）
     - 将 Rust 异步跟踪功能的代码和文档整理完善，完成相应的代码注释和文档编写。
     - 准备测试用例，用于验证跟踪功能的完整性和健壮性。
     - 与同事进行一次代码审查，确保实现质量达到预期。

**12月 - 明年8月的总体计划**

**12月**
1. **rust eBPF in Linux => tracing rust program with async**
   - 熟悉 Linux 上的 eBPF 基础和 Rust 的 eBPF 库（例如 `redbpf`）。
   - 尝试在 Linux 环境中编写简单的 eBPF 程序来跟踪 Rust 异步函数。
   - 结合 Rust 异步跟踪的宏，探索在 Linux 中用 eBPF 动态获取程序运行数据的可能性。

**1月**
1. **实现 eBPF 与 Rust 异步跟踪的集成**
   - 集成 eBPF 与 Rust 异步追踪工具，获取更丰富的运行时信息。
   - 解决跨 Linux 内核与用户空间的跟踪数据问题，设计合适的数据展示形式。

**2月**
1. **ArceOS 宏内核（starry）开发**
   - 确定 ArceOS 宏内核的基础模块设计与实现思路，开始编写内核模块。
   - 初步实现核心调度模块与内存管理模块。

**3月**
1. **继续开发 ArceOS 宏内核**
   - 实现基本的设备驱动模块，确保可以管理 I/O 设备。
   - 测试基础的内核功能，确保稳定性和性能满足初步要求。

**4月**
1. **支持多种操作系统的集成与验证**
   - 进行 ArceOS 与 Linux 的多操作系统兼容性测试，确保基础功能可以相互连通。
   - 优化 Linux 与 ArceOS 的联动方案，例如共享硬件资源的处理方式。

**5月**
1. **jtag in openSBI (coprocessor)**
   - 学习 openSBI 和 JTAG 的工作原理，理解它们如何在 RISC-V 平台上协作。
   - 在开发板上进行 JTAG 调试测试，尝试通过 JTAG 调试 coprocessor。

**6月**
1. **进一步开发 JTAG 支持**
   - 增强 JTAG 的调试能力，实现更细粒度的指令级调试。
   - 编写相关文档，详细说明如何使用 JTAG 调试 openSBI 和 coprocessor。

**7月**
1. **支持 x86 物理机（乾云工控机）**
   - 在乾云工控机上部署 ArceOS，进行物理机环境的适配与调优。
   - 解决硬件兼容性问题，确保操作系统能在不同类型的硬件平台上稳定运行。

**8月**
1. **项目整合与最终测试**
   - 进行整体功能的整合和全面测试，解决各平台、各功能模块的集成问题。
   - 编写最终的用户文档和开发文档，准备项目的最终展示和交付。


